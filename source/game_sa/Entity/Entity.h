/*
    Plugin-SDK file
    Authors: GTA Community. See more here
    https://github.com/DK22Pac/plugin-sdk
    Do not delete this comment block. Respect others' work!
*/
#pragma once

#include "Placeable.h"
#include "Reference.h"
#include "Rect.h"
#include "ColModel.h"

#include "eEntityType.h"
#include "eEntityStatus.h"
#include "eModelID.h"
#include "eAreaCodes.h"

class C2dEffect;
class CObject;
class CVehicle;
class CTrain;
class CBike;
class CBmx;
class CBoat;
class CAutomobile;
class CBike;
class CTrain;
class CPed;
class CObject;
class CBuilding;
class CDummy;
class CBuilding;
class CDummy;
class CPhysical;
class CBaseModelInfo;

class NOTSA_EXPORT_VTABLE CEntity : public CPlaceable {
public:
    struct CEntityInfo {
        eEntityType   m_nType : 3;   // Mask: & 0x7  = 7
        eEntityStatus m_nStatus : 5; // Mask: & 0xF8 = 248 (Remember: In the original code unless this was left shifted the value it's compared to has to be left shifted by 3!)
    };

    union {
        struct RwObject* m_pRwObject;
        struct RpClump*  m_pRwClump;
        struct RpAtomic* m_pRwAtomic;
    };

    union {
        struct {
            /* https://github.com/multitheftauto/mtasa-blue/blob/master/Client/game_sa/CEntitySA.h */
            bool m_bUsesCollision : 1;               // does entity use collision
            bool m_bCollisionProcessed : 1;          // has object been processed by a ProcessEntityCollision function
            bool m_bIsStatic : 1;                    // is entity static
            bool m_bHasContacted : 1;                // has entity processed some contact forces
            bool m_bIsStuck : 1;                     // is entity stuck
            bool m_bIsInSafePosition : 1;            // is entity in a collision free safe position
            bool m_bWasPostponed : 1;                // was entity control processing postponed
            bool m_bIsVisible : 1;                   // is the entity visible

            bool m_bIsBIGBuilding : 1;               // Set if this entity is a big building
            bool m_bRenderDamaged : 1;               // use damaged LOD models for objects with applicable damage
            bool m_bStreamingDontDelete : 1;         // Don't let the streaming remove this
            bool m_bRemoveFromWorld : 1;             // remove this entity next time it should be processed
            bool m_bHasHitWall : 1;                  // has collided with a building (changes subsequent collisions)
            bool m_bImBeingRendered : 1;             // don't delete me because I'm being rendered
            bool m_bDrawLast : 1;                    // draw object last
            bool m_bDistanceFade : 1;                // Fade entity because it is far away

            bool m_bDontCastShadowsOn : 1;           // Don't cast shadows on this object
            bool m_bOffscreen : 1;                   // offscreen flag. This can only be trusted when it is set to true
            bool m_bIsStaticWaitingForCollision : 1; // this is used by script created entities - they are static until the collision is loaded below them
            bool m_bDontStream : 1;                  // tell the streaming not to stream me
            bool m_bUnderwater : 1;                  // this object is underwater change drawing order
            bool m_bHasPreRenderEffects : 1;         // Object has a prerender effects attached to it
            bool m_bIsTempBuilding : 1;              // whether the building is temporary (i.e. can be created and deleted more than once)
            bool m_bDontUpdateHierarchy : 1;         // Don't update the animation hierarchy this frame

            bool m_bHasRoadsignText : 1;             // entity is roadsign and has some 2dEffect text stuff to be rendered
            bool m_bDisplayedSuperLowLOD : 1;
            bool m_bIsProcObject : 1;                // set object has been generated by procedural object generator
            bool m_bBackfaceCulled : 1;              // has backface culling on
            bool m_bLightObject : 1;                 // light object with directional lights
            bool m_bUnimportantStream : 1;           // set that this object is unimportant, if streaming is having problems
            bool m_bTunnel : 1;                      // Is this model part of a tunnel
            bool m_bTunnelTransition : 1;            // This model should be rendered from within and outside the tunnel
        };

        uint32 m_nFlags;
    };

    union {
        struct {
            uint16 m_nRandomSeedUpperByte : 8;
            uint16 m_nRandomSeedSecondByte : 8;
        };

        uint16 m_nRandomSeed;
    };

    uint16 m_nModelIndex;

    CReference* m_pReferences;

protected:
    CLink<CEntity*>* m_pStreamingLink;

    uint16     m_ScanCode;
    uint8      m_IplIndex;
    eAreaCodes m_AreaCode;

    union {
        int32    m_nLodIndex; // -1 - without LOD model
        CEntity* m_pLod;
    };

    uint8 m_NumLodChildren;

    int8 m_NumLodChildrenRendered;

    CEntityInfo m_info;

public:
    CEntity();
    ~CEntity() override;

    virtual void Add();
    virtual void Add(const CRect& rect);
    virtual void Remove();

    void SetTypeBuilding() { SetType(ENTITY_TYPE_BUILDING); }
    void SetTypeVehicle()  { SetType(ENTITY_TYPE_VEHICLE); }
    void SetTypePed()      { SetType(ENTITY_TYPE_PED); }
    void SetTypeObject()   { SetType(ENTITY_TYPE_OBJECT); }
    void SetTypeDummy()    { SetType(ENTITY_TYPE_DUMMY); }

    [[nodiscard]] bool GetIsTypeBuilding() const { return GetType() == ENTITY_TYPE_BUILDING; }
    [[nodiscard]] bool GetIsTypeVehicle()  const { return GetType() == ENTITY_TYPE_VEHICLE; }
    [[nodiscard]] bool GetIsTypePed()      const { return GetType() == ENTITY_TYPE_PED; }
    [[nodiscard]] bool GetIsTypeObject()   const { return GetType() == ENTITY_TYPE_OBJECT; }
    [[nodiscard]] bool GetIsTypeDummy()    const { return GetType() == ENTITY_TYPE_DUMMY; }
    [[nodiscard]] bool GetIsTypePhysical() const { return GetType() > ENTITY_TYPE_BUILDING && GetType() < ENTITY_TYPE_DUMMY; } // 0x4DA030, orig GetIsPhysical

    void SetType(eEntityType type) { m_info.m_nType = type; }
    [[nodiscard]] auto GetType() const noexcept { return m_info.m_nType; }

    void SetStatus(eEntityStatus status) { m_info.m_nStatus = status; }
    [[nodiscard]] auto GetStatus() const noexcept { return m_info.m_nStatus; }

    // 0x541F70
    bool TreatAsPlayerForCollisions() {
        return GetStatus() == STATUS_PLAYER;
    }

    void SetUsesCollision(bool usesCollision) { m_bUsesCollision = usesCollision; }
    bool GetUsesCollision() const { return m_bUsesCollision; }
    void SetCollisionProcessed(bool collisionProcessed) { m_bCollisionProcessed = collisionProcessed; }
    bool GetCollisionProcessed() const { return m_bCollisionProcessed; } // unused
    virtual void SetIsStatic(bool isStatic) { m_bIsStatic = isStatic; } // 0x403E20
    bool GetIsStatic() const { return m_bIsStatic || m_bIsStaticWaitingForCollision; } // 0x4633E0
    void SetHasContacted(bool hasContacted) { m_bHasContacted = hasContacted; }
    bool GetHasContacted() const { return m_bHasContacted; }
    void SetIsStuck(bool isStuck) { m_bIsStuck = isStuck; }
    bool GetIsStuck() const { return m_bIsStuck; }
    void SetIsInSafePosition(bool isInSafePosition) { m_bIsInSafePosition = isInSafePosition; }
    bool GetIsInSafePosition() const { return m_bIsInSafePosition; }
    void SetWasPostponed(bool wasPostponed) { m_bWasPostponed = wasPostponed; }
    bool GetWasPostponed() const { return m_bWasPostponed; }
    void SetIsVisible(bool isVisible) { m_bIsVisible = isVisible; }
    bool GetIsVisible() const { return m_bIsVisible; }
    void SetHasHitWall(bool hasHitWall) { m_bHasHitWall = hasHitWall; }
    bool GetHasHitWall() const { return m_bHasHitWall; }
    void SetIsBackfaceCulled(bool backfaceCulled) { m_bBackfaceCulled = backfaceCulled; }
    bool GetIsBackfaceCulled() const { return m_bBackfaceCulled; } // unused
    void SetIsUnimportantStream(bool unimportantStream) { m_bUnimportantStream |= unimportantStream; }

    void SetScanCode(uint16 scanCode) { m_ScanCode = scanCode; }
    uint16 GetScanCode() const { return m_ScanCode; }
    void SetAreaCode(eAreaCodes areaCode) { m_AreaCode = areaCode; }
    eAreaCodes GetAreaCode() const { return m_AreaCode; }
    void SetIplIndex(uint8 iplIndex) { m_IplIndex = iplIndex; }
    uint8 GetIplIndex() { return m_IplIndex; }

    virtual void SetModelIndex(uint32 index);
    virtual void SetModelIndexNoCreate(uint32 index);
    uint32 GetModelIndex() const { return m_nModelIndex; }
    auto GetModelId() const { return (eModelID)m_nModelIndex; } // NOTSA
    RwObject* GetRwObject() const { return m_pRwObject; }
    virtual void CreateRwObject();
    void AttachToRwObject(RwObject* object, bool updateMatrix);
    void DetachFromRwObject();
    virtual void DeleteRwObject();

    RwMatrix* GetRwMatrix();
    void UpdateRwMatrix();

    CVector GetBoundCentre() const;
    void GetBoundCentre(CVector& outCentre) const;

    float GetBoundRadius() const;
    virtual CRect GetBoundRect() const;

    CColModel* GetColModel() const;

    // is entity touching entity
    bool GetIsTouching(CEntity* entity) const;
    // is entity touching sphere
    bool GetIsTouching(const CVector& centre, float radius) const;

    bool GetIsOnScreen();
    bool GetIsBoundingBoxOnScreen();
    bool IsEntityOccluded();

    bool IsInCurrentArea() const;
    bool IsInArea(int32 area);
    bool IsVisible();
    bool IsVisibleComplex() { return IsVisible(); } // unused

    virtual void ProcessControl() { /* Do nothing */ } // 0x403E40
    virtual void ProcessCollision() { /* Do nothing */ } // 0x403E50
    virtual void ProcessShift() { /* Do nothing */ } // 0x403E60
    virtual bool TestCollision(bool applySpeed) { return false; } // 0x403E70
    virtual void Teleport(CVector newCoors, bool clearOrientation) { /* Do nothing */ } // 0x403E80
    virtual void SpecialEntityPreCollisionStuff(CPhysical* colPhysical, bool doingShift, bool& skipTestEntirely, bool& skipCol, bool& forceBuildingCol, bool& forceSoftCol) { /* Do nothing */ } // 0x403E90
    virtual uint8 SpecialEntityCalcCollisionSteps(bool& doPreCheckAtFullSpeed, bool& doPreCheckAtHalfSpeed) { return 1; } // 0x403EA0

    void UpdateRwFrame();
    void UpdateRpHAnim();

    bool HasPreRenderEffects();
    bool DoesNotCollideWithFlyers();
    virtual void PreRender();
    virtual void Render();
    void UpdateAnim();

    void BuildWindSockMatrix();
    bool LivesInThisNonOverlapSector(int32 x, int32 y);
    float GetDistanceFromCentreOfMassToBaseOfModel() const;

    void ProcessLightsForEntity();

    void RemoveEscalatorsForEntity();

    virtual bool SetupLighting();
    virtual void RemoveLighting(bool reset);

    void SetupBigBuilding();

    void RegisterReference(CEntity** entity);

    void CleanUpOldReference(CEntity** entity);
    void ResolveReferences();
    void PruneReferences();
    void ModifyMatrixForTreeInWind();
    void ModifyMatrixForBannerInWind();
    void ModifyMatrixForCrane();
    void PreRenderForGlassWindow();

    virtual void FlagToDestroyWhenNextProcessed() { /* Do nothing */ } // 0x403EB0

    void SetRwObjectAlpha(int32 alpha);

    void CreateEffects();
    void DestroyEffects();
    void RenderEffects();

    void SetLodIndex(uint32 lodIndex) { m_nLodIndex = lodIndex; }
    uint32 GetLodIndex() { return m_nLodIndex; }
    void SetLod(CEntity* lod) { m_pLod = lod; }
    CEntity* GetLod() { return m_pLod; }

    void AddLodChildren() { m_NumLodChildren++; } // orig AddLodChild
    void RemoveLodChildren() { m_NumLodChildren--; } // orig RemoveLodChild
    int32 GetNumLodChildren() { return m_NumLodChildren; }

    void AddLodChildrenRendered() { m_NumLodChildrenRendered++; } // orig AddLodChildRendered
    void ResetLodChildrenRendered() { m_NumLodChildrenRendered = 0; } // orig ResetLodRenderedCounter
    bool HasLodChildrenRendered() { return m_NumLodChildrenRendered > 0; } // orig HasLodChildBeenRendered
    int32 GetNumLodChildrenRendered() { return m_NumLodChildrenRendered; }
    void SetCannotLodChildrenRender() { m_NumLodChildrenRendered = 128; } // orig SetLodChildCannotRender
    bool CanLodChildrenRender() { return m_NumLodChildrenRendered != 128; } // orig CanLodChildRender

    // 128 = displaySuperLowLodFlag, yes, this is very hacky. Blame R*

    CVector* FindTriggerPointCoors(CVector* pOutVec, int32 index);
    void CalculateBBProjection(CVector* point1, CVector* point2, CVector* point3, CVector* point4);

    C2dEffect* GetRandom2dEffect(int32 effectType, bool mustBeFree);

    CVector TransformFromObjectSpace(const CVector& offset) const;
    CVector* TransformFromObjectSpace(CVector& outPos, const CVector& offset) const;
    RwMatrix* GetModellingMatrix();

    // NOTSA section

    // Always returns a non-null value. In case there's no LOD object `this` is returned
    CEntity* FindLastLOD() noexcept;

    CBaseModelInfo* GetModelInfo() const;

    CCollisionData* GetColData() { return GetColModel()->m_pColData; }

    // Wrapper around the mess called `CleanUpOldReference`
    // Takes in `ref` (which is usually a member variable),
    // calls `CleanUpOldReference` on it, then sets it to `nullptr`
    // Used often in the code.
    template<typename T>
    static void ClearReference(T*& ref) requires std::is_base_of_v<CEntity, T> {
        if (ref) {
            ref->CleanUpOldReference(reinterpret_cast<CEntity**>(&ref));
            ref = nullptr;
        }
    }

    // Wrapper around the mess called "entity references"
    // This one sets the given `inOutRef` member variable to `entity`
    // + clears the old entity (if any)
    // + set the new entity (if any)
    template<typename T, typename Y>
        requires std::is_base_of_v<CEntity, T> && std::is_base_of_v<CEntity, Y>
    static void ChangeEntityReference(T*& inOutRef, Y* entity) {
        ClearReference(inOutRef); // Clear old
        if (entity) { // Set new (if any)
            inOutRef = entity;
            inOutRef->RegisterReference(reinterpret_cast<CEntity**>(&inOutRef));
        }
    }

    // Similar to `ChangeEntityReference`, but doesn't clear the old reference
    template<typename T, typename Y>
        requires std::is_base_of_v<CEntity, T> && std::is_base_of_v<CEntity, Y>
    static void SetEntityReference(T*& inOutRef, Y* entity) {
        inOutRef = entity;
        inOutRef->RegisterReference(reinterpret_cast<CEntity**>(&inOutRef));
    }

    // Register a reference to the entity that is stored in that given reference
    template<typename T>
    static void RegisterReference(T*& ref) requires std::is_base_of_v<CEntity, T> {
        ref->RegisterReference(reinterpret_cast<CEntity**>(&ref));
    }

    template<typename T>
    static void CleanUpOldReference(T*& ref) requires std::is_base_of_v<CEntity, T> {
        ref->CleanUpOldReference(reinterpret_cast<CEntity**>(&ref));
    }

    template<typename T>
    static void SafeRegisterRef(T*& e) requires std::is_base_of_v<CEntity, T> {
        if (e) {
            e->RegisterReference(reinterpret_cast<CEntity**>(&e));
        }
    }

    template<typename T>
    static void SafeCleanUpRef(T*& e) requires std::is_base_of_v<CEntity, T> {
        if (e) {
            e->CleanUpOldReference(reinterpret_cast<CEntity**>(&e));
        }
    }

public:
    // NOTSA section

    [[nodiscard]] bool IsModelTempCollision() const { return GetModelIndex() >= MODEL_TEMPCOL_DOOR1 && GetModelIndex() <= MODEL_TEMPCOL_BODYPART2; }
    [[nodiscard]] bool IsRCCar() const { return GetModelIndex() == MODEL_RCBANDIT || GetModelIndex() == MODEL_RCTIGER || GetModelIndex() == MODEL_RCCAM; }

    auto AsPhysical()         { return reinterpret_cast<CPhysical*>(this); }
    auto AsVehicle()          { return reinterpret_cast<CVehicle*>(this); }
    auto AsVehicle()    const { return reinterpret_cast<const CVehicle*>(this); }
    auto AsAutomobile()       { return reinterpret_cast<CAutomobile*>(this); }
    auto AsAutomobile() const { return reinterpret_cast<const CAutomobile*>(this); }
    auto AsBike()             { return reinterpret_cast<CBike*>(this); }
    auto AsBike()       const { return reinterpret_cast<const CBike*>(this); }
    auto AsBmx()              { return reinterpret_cast<CBmx*>(this); }
    auto AsBmx()        const { return reinterpret_cast<const CBmx*>(this); }
    auto AsBoat()             { return reinterpret_cast<CBoat*>(this); }
    auto AsBoat()       const { return reinterpret_cast<const CBoat*>(this); }
    auto AsTrain()            { return reinterpret_cast<CTrain*>(this); }
    auto AsTrain()      const { return reinterpret_cast<const CTrain*>(this); }
    auto AsPed()              { return reinterpret_cast<CPed*>(this); }
    auto AsPed()        const { return reinterpret_cast<const CPed*>(this); }
    auto AsObject()           { return reinterpret_cast<CObject*>(this); }
    auto AsBuilding()         { return reinterpret_cast<CBuilding*>(this); }
    auto AsDummy()            { return reinterpret_cast<CDummy*>(this); }

    bool ProcessScan();
    bool IsScanCodeCurrent() const;
    void SetCurrentScanCode();

private:
    friend void InjectHooksMain();
    static void InjectHooks();

    CEntity* Constructor() {
        this->CEntity::CEntity();
        return this;
    }

    CEntity* Destructor() {
        this->CEntity::~CEntity();
        return this;
    }
};

VALIDATE_SIZE(CEntity, 0x38);

inline bool CEntity::IsInCurrentArea() const {
    return GetAreaCode() == CGame::currArea || GetAreaCode() == AREA_CODE_13;
}

inline bool CEntity::IsInArea(int32 area) {
    return GetAreaCode() == area || GetAreaCode() == AREA_CODE_13;
}

inline RwMatrix* CEntity::GetRwMatrix() {
    return RwFrameGetMatrix(RwFrameGetParent(GetRwObject()));
}

// Rw callbacks:

static RpAtomic* SetAtomicAlpha(RpAtomic* atomic, void* data);
static RpMaterial* SetCompAlphaCB(RpMaterial* material, void* data);
static RpMaterial* MaterialUpdateUVAnimCB(RpMaterial* material, void* data);

bool IsEntityPointerValid(CEntity* entity);

static inline float& GAME_GRAVITY = *(float*)0x863984; // default 0.008f
